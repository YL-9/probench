# 冰冰的异或

## 题目描述

给定一个正整数 $n$，求 $\text{mex}\\{i\oplus j\mid i\in [1,n],j\in[1,n] \\}$。  
  


此处的 $\text{mex}$ 是指集合中不存在的最小非负整数。 

  


此处的 $\oplus$ 表示按位异或运算，按位异或是一种二进制操作，它操作两个长度相等的二进制串，对每个对应的位对执行逻辑异或操作，得到一个和这两个二进制串长度相同的二进制串。如果只有一个位为 $1$，则每个位置的结果为 $1$，但如果两个位都为 $0$ 或两个位都为 $1$，则结果为 $0$。简单来说，我们对这两个二进制串的每个位分别进行比较，如果这两个二进制串某一位，它们的位上的数不同，则按位异或运算的结果这一位为 $1$，如果它们相同，则按位异或运算的结果这一位为 $0$。 

  


例如：$0010\oplus 1010=1000$。 

  


对于两个十进制数的按位异或运算，其结果为这两个数转换成二进制后进行上述按位异或运算后的结果的十进制表达。 

  


例如：十进制下 $5\oplus 3= 0101\oplus 0011=0110=6$  


## 输入描述:
    
    
    第一行一个正整数 $t(1\leq t\leq 10^5)$ 表示数据组数。  
      
    接下来 $t$ 行，每行一个正整数 $n(1\leq n\leq 10^{18})$。  
    

## 输出描述:
    
    
    共 $t$ 行，每行一个非负整数表示 $\text{mex}\{i\oplus j\}(i,j\in[1,n])$。

示例1 

## 输入
    
    
    2
    1
    3

## 输出
    
    
    1
    4


## 时空限制

时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
64bit IO Format: %lld