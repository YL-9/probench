# 最大稳定数值

## 题目描述

$Bingbong$有一棵结点总数为 $n$ 且根节点编号为 $1$ 的有根树，第 $i$ 个结点的权值为 $a_i$。  
  
一个结点称为"支撑结点"当且仅当其满足以下所有条件：  
  
上层结点：除自身结点以外的祖先节点。  
  
下层结点：除自身结点以外的子孙节点。  
  
1.该结点的所有上层结点权值之和**大于等于** 当前结点的权值（如果无上层结点，则其权值之和为$0$)。  
  
2.该结点的所有下层结点权值之和**小于等于** 当前结点的权值（如果无下层结点，则其权值之和为$0$)。  
  
一棵有根树的稳定值为该有根树"支撑结点"的个数，为了让这棵树的稳定值达到最大，$Bingbong$得到了一次删除树边的机会(**可以不删除**)，即选择两个结点 $u,v$ ( $u$ 是 $v$ 的父节点),然后把连接 $u,v$ 的边删除，即把以 $v$ 为根的子树删除。请你帮助他计算出该有根树可能达到的最大稳定值。  


  


注：当选择删除子树时，该子树的支撑结点不计入答案。 

  


请回忆：  
  
\- 祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；  
\- 子孙结点：某一结点的子树中的所有结点是这个结点的子孙；

## 输入描述:
    
    
    第一行一个整数 $n(1\leq n\leq 10^5)$，表示该有根树的结点个数。  
      
    第二行包含 $n$ 个整数，第 $i$ 个数为 $a_i(1\leq a_i\leq 10^9)$，表示第 $i$ 个结点的权值。  
      
    第三行包含 $n$ 个整数，第 $i$ 个数为 $father_i(1\leq father_i\leq i-1)$，表示第 $i$ 个结点的父亲结点的编号，特别地 $father_1=0$。

## 输出描述:
    
    
    一个整数，表示该有根树可能达到的最大稳定值。

示例1 

## 输入
    
    
    5
    10 2 3 1 2
    0 1 1 2 3

## 输出
    
    
    4

示例2 

## 输入
    
    
    6
    10 10 3 10 7 40
    0 1 1 2 3 4

## 输出
    
    
    3

## 备注:
    
    
    对于样例一：无需删边。
    
    对于样例二：删除结点4和结点6的边即可。


## 时空限制

时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
64bit IO Format: %lld