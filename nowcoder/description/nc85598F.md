# 绝妙的手法

## 题目描述

本题出题时想到的贪心做法是错误的，评测数据也是按照出题时的std造的，目前本题没有正确解法，不建议大家做这道题。

  


给定一个长度为 $n$ 的序列 $A$，你每次可以做如下操作： 

  * 每次选择**两个****不同** 的下标 $i,j$，令 $A_i= A_i+A_j$ 

jackle 想问你最少操作几次，可以使得序列中**恰好有** $m$**个****正数** 。

## 输入描述:
    
    
    注意本题有多组测试数据。
    
    第一行先输入 $1$ 个整数 $T(1\leq T\leq 2\times 10^5)$，表示数据组数。
    
    对于每组测试数据：
    
    第一行输入 $2$ 个整数 $n,m\ (1\leq n \leq 2\times 10^5,0\leq m\leq 2\times 10^5)$。
    
    第二行输入 $n$ 个整数 $A_i\ (-10^{12}\leq A_i \leq 10^{12})$。
    
    题目保证 $\sum n\leq 2\times 10^5$。

## 输出描述:
    
    
    对于每组测试数据：
    
    如果能通过操作，使得序列中恰好有 $m$ 个正数，请你输出最小操作次数；否则请你输出 $-1$。

示例1 

## 输入
    
    
    1
    4 3
    -1 -1 1 2

## 输出
    
    
    1

## 说明
    
    
    显然操作一次即可：选择 $i=1,j=4$，令 $A_1= A_1+A_4=-1+2=1$，操作完之后 $A_1=1$，那么此时序列中恰好 $3$ 个正数。

示例2 

## 输入
    
    
    1
    5 3
    0 0 0 0 0

## 输出
    
    
    -1

## 说明
    
    
    由于所有数都是 $0$，所以无论怎么执行 $A_i=A_i+A_j$，序列中的数都还是 $0$，所以一定无法操作使得序列恰好出现 $3$ 个正数。

示例3 

## 输入
    
    
    2
    4 2
    -10 1 1 1
    6 4
    4 -2 -2 -3 2 -4

## 输出
    
    
    1
    2


## 时空限制

时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
64bit IO Format: %lld